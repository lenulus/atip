# RFC: Agent Tool Introspection Protocol (ATIP)

**RFC Number**: ATIP-0001  
**Status**: Draft  
**Authors**: [Community Proposal]  
**Created**: January 2026  
**Version**: 0.1.0

---

## Abstract

This document specifies a lightweight protocol for AI agents to discover and understand local command-line tools without requiring running server processes. The Agent Tool Introspection Protocol (ATIP) defines a simple `--agent` flag convention that outputs structured JSON metadata to stdout, canonical file locations for tool registries following XDG conventions, and a minimal schema for describing tool capabilities, side effects, and safety properties. ATIP complements the Model Context Protocol (MCP) by providing zero-infrastructure introspection suitable for agentic coding tools like Claude Code, Gemini CLI, and similar systems, while MCP continues to handle execution, authentication, and bidirectional communication for complex tool interactions.

---

## 1. Motivation

### The gap between MCP and practical local tool discovery

The Model Context Protocol represents a significant advance in standardizing AI-tool communication. However, MCP's architecture assumes tools expose themselves via long-running server processes—either local STDIO servers or remote HTTP endpoints. This design solves important problems: security isolation, bidirectional communication, streaming responses, and multi-client scenarios.

For local tool introspection, this architecture introduces unnecessary overhead. When an AI coding assistant simply needs to understand what `kubectl`, `terraform`, or `gh` can do, spinning up server processes for each tool is excessive. Consider the workflow:

**Current state with MCP:**
1. Tool author must implement MCP server (20-100 lines minimum)
2. Host application must configure and launch server process
3. JSON-RPC handshake and capability negotiation
4. Finally, `tools/list` returns metadata
5. Server process continues running or must be terminated

**Proposed ATIP approach:**
1. Execute `tool --agent`
2. Parse JSON from stdout
3. Done

### Real-world pain points this RFC addresses

**Agent developers** currently face a fragmented landscape. Each tool has different introspection mechanisms: `--help` output varies wildly, man pages exist for some tools, shell completion specs exist for others. Parsing `--help` text is unreliable—too variable across tools to build robust metadata extraction.

**Tool authors** wanting to support AI agents face a choice: implement a full MCP server (significant effort) or accept that agents will guess at tool capabilities from help text. A simpler option would accelerate adoption.

**Users of multiple AI coding tools** (Claude Code, Gemini CLI, Cursor, Windsurf) would benefit from tools that self-describe once in a standard format, rather than requiring per-tool configuration in each AI application.

### Why not just extend MCP?

MCP serves a different purpose: it's an execution and communication protocol. ATIP is purely introspection. The separation of concerns is deliberate:

| Concern | Protocol |
|---------|----------|
| Tool discovery/metadata | ATIP |
| Tool execution | MCP (or direct invocation) |
| Streaming responses | MCP |
| Bidirectional communication | MCP |
| Authentication | MCP |

This RFC proposes ATIP as a complement to MCP, not a replacement. An agent might use ATIP to quickly scan available tools, then use MCP for execution when the tool supports it, or fall back to direct invocation when it doesn't.

---

## 2. Design Goals

### 2.1 Simplicity

The protocol must be simple enough that a tool author can add support in under 30 minutes. The `--agent` flag should output JSON to stdout. No new dependencies, no running processes, no configuration files required for basic support.

### 2.2 Zero infrastructure

No servers, no daemons, no sockets, no ports. Tool introspection should work on a fresh system with only the tool binary installed. This enables use in containers, CI environments, and restrictive corporate environments where running additional processes is problematic.

### 2.3 Incremental adoption

Tools can adopt ATIP without breaking existing behavior. The `--agent` flag is purely additive. Tools without native support can be wrapped via shims. Partial implementations (e.g., only basic metadata, no side-effect annotations) are valid and useful.

### 2.4 Composability

ATIP metadata can be layered. Base tool metadata can be extended with organizational patterns, workflow definitions, and institutional knowledge stored in separate files. This supports enterprise scenarios where security teams annotate tools with permission requirements.

### 2.5 Compatibility with existing standards

ATIP builds on proven patterns: JSON Schema for parameter definitions, XDG Base Directory Specification for file locations, Fig completion spec patterns for command structure, and MCP's tool schema design for field naming. Agents already handling these formats need minimal adaptation.

---

## 3. Specification

### 3.1 The `--agent` flag convention

Tools supporting ATIP MUST respond to the `--agent` flag by outputting valid JSON to stdout and exiting with code 0 on success.

```bash
# Introspection request
$ mytool --agent

# Response: JSON to stdout
{
  "atip": "0.1",
  "name": "mytool",
  "version": "2.3.1",
  ...
}
```

**Behavioral requirements:**

1. `--agent` MUST NOT perform any side effects (no network calls, no file writes, no prompts)
2. Output MUST be valid JSON (UTF-8 encoded)
3. Exit code MUST be 0 on success, non-zero on failure
4. If `--agent` is combined with other flags, behavior is undefined (implementations MAY ignore other flags or MAY return an error)
5. Output MUST go to stdout; diagnostic messages MAY go to stderr

**Discovery probing:**

Agents can detect ATIP support by running `tool --agent` and checking:
- Exit code is 0
- Output parses as valid JSON
- Output contains `"atip"` version field

### 3.2 Schema definition for tool metadata

The following schema defines the structure of ATIP metadata. Fields marked REQUIRED must be present; all others are optional.

#### 3.2.1 Root object

```json
{
  "$schema": "https://atip.dev/schema/0.1.json",
  "atip": "0.1",
  "name": "gh",
  "version": "2.45.0",
  "title": "GitHub CLI",
  "description": "Work seamlessly with GitHub from the command line",
  "homepage": "https://cli.github.com",
  "license": "MIT",
  "commands": { ... },
  "globalOptions": [ ... ],
  "authentication": { ... },
  "effects": { ... },
  "patterns": [ ... ]
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `atip` | string | YES | Protocol version (semver: "0.1") |
| `name` | string | YES | Command name (matches executable) |
| `version` | string | YES | Tool version (semver preferred) |
| `title` | string | NO | Human-readable name |
| `description` | string | YES | One-line description of tool purpose |
| `homepage` | string | NO | URL for documentation |
| `license` | string | NO | SPDX license identifier |
| `commands` | object | NO | Subcommand definitions |
| `globalOptions` | array | NO | Options available to all commands |
| `authentication` | object | NO | Authentication requirements |
| `effects` | object | NO | Global side-effect declarations |
| `patterns` | array | NO | Common usage patterns |

#### 3.2.2 Command object

Commands represent invocable actions. For tools with subcommands (like `git`, `docker`, `kubectl`), each subcommand is a nested command.

```json
{
  "commands": {
    "pr": {
      "description": "Manage pull requests",
      "commands": {
        "create": {
          "description": "Create a pull request",
          "arguments": [
            {
              "name": "title",
              "type": "string",
              "required": false,
              "description": "PR title (prompted if not supplied)"
            }
          ],
          "options": [
            {
              "name": "draft",
              "flags": ["-d", "--draft"],
              "type": "boolean",
              "default": false,
              "description": "Mark pull request as draft"
            },
            {
              "name": "base",
              "flags": ["-B", "--base"],
              "type": "string",
              "description": "Base branch for the pull request"
            }
          ],
          "effects": {
            "network": true,
            "idempotent": false,
            "reversible": true,
            "creates": ["pull_request"]
          },
          "examples": [
            "gh pr create --title \"Fix bug\" --body \"Description\"",
            "gh pr create --draft --base main"
          ]
        }
      }
    }
  }
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `description` | string | YES | What this command does |
| `commands` | object | NO | Nested subcommands |
| `arguments` | array | NO | Positional arguments |
| `options` | array | NO | Flag options |
| `effects` | object | NO | Side-effect declarations |
| `examples` | array | NO | Example invocations |
| `authentication` | object | NO | Auth requirements for this command |
| `deprecated` | boolean | NO | Whether command is deprecated |
| `hidden` | boolean | NO | Whether command should be hidden from default help |

#### 3.2.3 Argument object

Arguments are positional parameters to commands.

```json
{
  "arguments": [
    {
      "name": "file",
      "type": "file",
      "required": true,
      "description": "File to process",
      "variadic": false
    }
  ]
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `name` | string | YES | Argument name for display |
| `type` | string | YES | See Type System below |
| `description` | string | YES | What this argument represents |
| `required` | boolean | NO | Default: true for positional args |
| `default` | any | NO | Default value if not provided |
| `variadic` | boolean | NO | Accepts multiple values |
| `enum` | array | NO | Allowed values |
| `pattern` | string | NO | Regex pattern for validation |

#### 3.2.4 Option object

Options are flag-style parameters.

```json
{
  "options": [
    {
      "name": "output",
      "flags": ["-o", "--output"],
      "type": "enum",
      "enum": ["json", "yaml", "text", "table"],
      "default": "text",
      "description": "Output format",
      "envVar": "GH_OUTPUT_FORMAT"
    }
  ]
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `name` | string | YES | Option name (for programmatic use) |
| `flags` | array | YES | CLI flags ["-x", "--extended"] |
| `type` | string | YES | See Type System below |
| `description` | string | YES | What this option controls |
| `required` | boolean | NO | Default: false |
| `default` | any | NO | Default value |
| `enum` | array | NO | Allowed values (for enum type) |
| `envVar` | string | NO | Environment variable override |
| `exclusive` | array | NO | Mutually exclusive with these options |

#### 3.2.5 Type system

ATIP defines the following primitive types:

| Type | Description | JSON Schema equivalent |
|------|-------------|------------------------|
| `string` | Text value | `{"type": "string"}` |
| `integer` | Whole number | `{"type": "integer"}` |
| `number` | Floating point | `{"type": "number"}` |
| `boolean` | True/false flag | `{"type": "boolean"}` |
| `file` | File path | `{"type": "string", "format": "file-path"}` |
| `directory` | Directory path | `{"type": "string", "format": "directory-path"}` |
| `url` | URL | `{"type": "string", "format": "uri"}` |
| `enum` | One of allowed values | `{"type": "string", "enum": [...]}` |
| `array` | List of values | `{"type": "array", "items": {...}}` |

For complex types, implementations MAY include a `schema` field with full JSON Schema.

#### 3.2.6 Effects object (side effects and safety properties)

The effects object declares what changes a command may make. This enables agents to make informed decisions about tool usage, especially in autonomous scenarios.

```json
{
  "effects": {
    "filesystem": {
      "read": true,
      "write": true,
      "delete": false,
      "paths": ["./", "~/.config/mytool/"]
    },
    "network": true,
    "subprocess": false,
    "idempotent": true,
    "reversible": false,
    "destructive": false,
    "creates": ["resource_type"],
    "modifies": ["resource_type"],
    "deletes": ["resource_type"],
    "cost": {
      "estimate": "low",
      "billable": false
    },
    "duration": {
      "typical": "1-5s",
      "timeout": "60s"
    }
  }
}
```

| Field | Type | Description |
|-------|------|-------------|
| `filesystem.read` | boolean | Reads files |
| `filesystem.write` | boolean | Writes/creates files |
| `filesystem.delete` | boolean | Deletes files |
| `filesystem.paths` | array | Paths that may be affected |
| `network` | boolean | Makes network requests |
| `subprocess` | boolean | Spawns child processes |
| `idempotent` | boolean | Safe to retry without side effects |
| `reversible` | boolean | Can be undone (how specified in description) |
| `destructive` | boolean | Permanently destroys data |
| `creates` | array | Resource types created |
| `modifies` | array | Resource types modified |
| `deletes` | array | Resource types deleted |
| `cost.estimate` | string | "none", "low", "medium", "high" |
| `cost.billable` | boolean | May incur financial cost |
| `duration.typical` | string | Expected execution time |
| `duration.timeout` | string | Recommended timeout |

#### 3.2.7 Authentication object

Declares authentication requirements for the tool or specific commands.

```json
{
  "authentication": {
    "required": true,
    "methods": [
      {
        "type": "token",
        "envVar": "GITHUB_TOKEN",
        "configPath": "~/.config/gh/hosts.yml",
        "description": "Personal access token or OAuth token"
      },
      {
        "type": "oauth",
        "setupCommand": "gh auth login",
        "scopes": ["repo", "read:org"]
      }
    ],
    "checkCommand": "gh auth status"
  }
}
```

| Field | Type | Description |
|-------|------|-------------|
| `required` | boolean | Whether auth is required |
| `methods` | array | Supported authentication methods |
| `methods[].type` | string | "token", "oauth", "api-key", "certificate", "none" |
| `methods[].envVar` | string | Environment variable for credentials |
| `methods[].configPath` | string | Path to config file with credentials |
| `methods[].setupCommand` | string | Command to set up authentication |
| `methods[].scopes` | array | Required permission scopes |
| `checkCommand` | string | Command to verify authentication status |

#### 3.2.8 Patterns array (workflow knowledge)

Patterns encode institutional knowledge about how tools are commonly used together. This enables agents to suggest appropriate workflows.

```json
{
  "patterns": [
    {
      "name": "feature-branch-workflow",
      "description": "Create a feature branch, make changes, open PR",
      "steps": [
        {"command": "gh repo clone {repo}", "description": "Clone repository"},
        {"command": "git checkout -b {branch}", "description": "Create branch"},
        {"command": "gh pr create", "description": "Open pull request"}
      ],
      "variables": {
        "repo": {"type": "string", "description": "Repository in owner/name format"},
        "branch": {"type": "string", "description": "Feature branch name"}
      },
      "tags": ["git", "github", "workflow"]
    }
  ]
}
```

### 3.3 Canonical file locations

Following the XDG Base Directory Specification, ATIP defines standard locations for tool registries and cached metadata.

#### 3.3.1 Directory structure

```
$XDG_DATA_HOME/agent-tools/          # Default: ~/.local/share/agent-tools/
├── registry.json                    # Index of discovered tools
├── tools/                           # Individual tool metadata
│   ├── gh.json                      # Cached metadata for 'gh'
│   ├── kubectl.json                 # Cached metadata for 'kubectl'
│   └── terraform.json               # Cached metadata for 'terraform'
├── patterns/                        # Workflow pattern definitions
│   ├── kubernetes-deploy.json       # K8s deployment patterns
│   └── github-workflow.json         # GitHub workflow patterns
└── shims/                           # Wrapper scripts for legacy tools
    ├── curl.json                    # ATIP metadata for curl
    └── rsync.json                   # ATIP metadata for rsync

$XDG_CONFIG_HOME/agent-tools/        # Default: ~/.config/agent-tools/
├── config.json                      # User preferences
├── trust.json                       # Tool trust settings
└── overrides/                       # User customizations
    └── gh.json                      # Override specific metadata

$XDG_CACHE_HOME/agent-tools/         # Default: ~/.cache/agent-tools/
└── discovery/                       # Cached discovery results
    └── path-scan-{hash}.json        # PATH scan cache

/usr/share/agent-tools/              # System-wide tool definitions
/usr/local/share/agent-tools/        # Locally installed system tools
```

#### 3.3.2 Registry file format

The registry maintains an index of known tools for quick lookup.

```json
{
  "version": "0.1",
  "updated": "2026-01-05T10:30:00Z",
  "tools": {
    "gh": {
      "path": "/opt/homebrew/bin/gh",
      "version": "2.45.0",
      "atipVersion": "0.1",
      "source": "native",
      "lastChecked": "2026-01-05T10:30:00Z",
      "metadataPath": "./tools/gh.json"
    },
    "curl": {
      "path": "/usr/bin/curl",
      "version": "8.4.0",
      "source": "shim",
      "shimPath": "./shims/curl.json",
      "lastChecked": "2026-01-05T10:30:00Z"
    }
  }
}
```

| Source | Description |
|--------|-------------|
| `native` | Tool natively supports `--agent` |
| `shim` | Metadata provided by external shim file |
| `inferred` | Metadata auto-generated from `--help` parsing |
| `manual` | User-provided metadata override |

### 3.4 Discovery mechanism

#### 3.4.1 Discovery algorithm

Agents SHOULD discover tools using this priority order:

1. **Explicit configuration**: User-specified tools in config
2. **Registry file**: Previously discovered tools in `registry.json`
3. **Canonical directories**: Scan `/usr/share/agent-tools/`, `$XDG_DATA_HOME/agent-tools/`
4. **PATH scanning**: Check executables in PATH for `--agent` support
5. **MCP servers**: Query running MCP servers for their tool lists

**PATH scanning algorithm:**

```
for each directory in $PATH:
    for each executable in directory:
        if not in skip_list and not recently_checked:
            run: executable --agent (with timeout)
            if exit_code == 0 and output is valid ATIP JSON:
                add to registry as "native"
            else:
                check for shim in shims/ directory
                if shim exists:
                    add to registry as "shim"
```

**Performance considerations:**
- PATH scanning SHOULD be limited to first run or explicit refresh
- Implementations SHOULD maintain a skip list of known non-ATIP tools
- Timeout for `--agent` probe SHOULD be 2 seconds maximum
- Results SHOULD be cached with version-based invalidation

#### 3.4.2 Tool resolution

When an agent needs metadata for a tool:

```
resolve(tool_name):
    1. Check overrides/$tool.json (user customizations)
    2. Check registry.json for cached entry
    3. If entry exists and not expired:
        - If source == "native": run $tool --agent
        - If source == "shim": load shim file
        - If source == "manual": load override file
    4. If not found, attempt discovery for this tool
    5. Return merged metadata (base + patterns + overrides)
```

### 3.5 Caching semantics

#### 3.5.1 Cache invalidation

Tool metadata SHOULD be refreshed when:
- Tool version changes (detected via `--version`)
- Cache entry is older than `maxAge` (default: 7 days)
- User explicitly requests refresh
- Tool's modification time changes

#### 3.5.2 Cache storage format

```json
{
  "tool": "gh",
  "version": "2.45.0",
  "atipVersion": "0.1",
  "cachedAt": "2026-01-05T10:30:00Z",
  "expiresAt": "2026-01-12T10:30:00Z",
  "checksum": "sha256:abc123...",
  "metadata": { /* full ATIP metadata */ }
}
```

### 3.6 Pattern and workflow layering

Patterns can be layered from multiple sources, enabling institutional knowledge to augment base tool metadata.

**Resolution order (later overrides earlier):**
1. Tool's built-in patterns (from `--agent` output)
2. System patterns (`/usr/share/agent-tools/patterns/`)
3. User patterns (`$XDG_DATA_HOME/agent-tools/patterns/`)
4. Project patterns (`.agent-tools/patterns/` in project root)

This enables:
- Tool authors to provide canonical patterns
- System administrators to define organizational workflows
- Users to customize for their preferences
- Projects to include project-specific patterns

---

## 4. Subagent Considerations

### 4.1 Shared tool knowledge

When multiple agents or subagents operate in the same environment, they need consistent tool understanding.

**Recommendations:**

1. **Single source of truth**: All agents SHOULD read from the same registry at `$XDG_DATA_HOME/agent-tools/registry.json`

2. **Lock-free reads**: The registry file format supports concurrent reads without locking

3. **Write coordination**: Updates to the registry SHOULD use atomic file replacement (write to temp, rename)

4. **Version stamping**: Each registry update increments a version number; agents can detect changes

### 4.2 Context sharing

Agents coordinating on a task may need to share tool context efficiently.

**Proposed format for agent-to-agent tool context:**

```json
{
  "toolContext": {
    "availableTools": ["gh", "kubectl", "terraform"],
    "authenticatedTools": ["gh"],
    "toolStates": {
      "kubectl": {
        "currentContext": "production",
        "namespace": "default"
      }
    },
    "recentCommands": [
      {"tool": "gh", "command": "pr list", "exitCode": 0}
    ]
  }
}
```

### 4.3 Capability delegation

A lead agent may delegate tool usage to subagents with restricted capabilities.

**Trust scoping pattern:**

```json
{
  "delegation": {
    "allowedTools": ["gh", "git"],
    "deniedCommands": ["gh repo delete", "git push --force"],
    "effectRestrictions": {
      "destructive": false,
      "network": true
    }
  }
}
```

---

## 5. Security Considerations

### 5.1 Trust boundaries

ATIP metadata is **descriptive, not prescriptive**. Agents MUST NOT trust tool metadata for security decisions without verification.

**Threat model:**
- Malicious tool could lie about effects (claim "filesystem.delete: false" but actually delete files)
- Shim files could be modified by attackers
- Cached metadata could be poisoned

**Mitigations:**
1. **Signature verification**: System-installed shims SHOULD be signed
2. **User confirmation**: Agents SHOULD confirm destructive operations regardless of metadata claims
3. **Sandbox verification**: Agents MAY run tools in sandboxes to verify declared effects
4. **Reputation system**: Future versions may include tool reputation/audit data

### 5.2 Permission scoping

The `authentication` and `effects` fields enable agents to make informed permission decisions:

```json
{
  "permissionPolicy": {
    "autoApprove": {
      "effects.filesystem.read": true,
      "effects.network": false
    },
    "requireConfirmation": {
      "effects.destructive": true,
      "effects.cost.billable": true
    },
    "deny": {
      "effects.filesystem.paths": ["/etc/*", "/var/*"]
    }
  }
}
```

### 5.3 Information disclosure

Tool metadata may reveal system configuration. Implementations SHOULD:
- Not include sensitive paths in cached metadata
- Allow users to redact specific fields
- Support private registries for enterprise environments

---

## 6. Adoption Path

### 6.1 For tool authors

**Minimal implementation (30 minutes):**

```python
#!/usr/bin/env python3
import json
import sys

def handle_agent_flag():
    metadata = {
        "atip": "0.1",
        "name": "mytool",
        "version": "1.0.0",
        "description": "Does something useful",
        "commands": {
            "run": {
                "description": "Execute the main function",
                "options": [
                    {
                        "name": "verbose",
                        "flags": ["-v", "--verbose"],
                        "type": "boolean",
                        "description": "Enable verbose output"
                    }
                ]
            }
        }
    }
    print(json.dumps(metadata, indent=2))
    sys.exit(0)

if __name__ == "__main__":
    if "--agent" in sys.argv:
        handle_agent_flag()
    # ... rest of tool
```

**Progressive enhancement:**
1. Start with basic metadata (name, version, description)
2. Add command structure
3. Add effects declarations
4. Add patterns

### 6.2 Shim approach for legacy tools

For tools that won't add native support, shim files provide metadata:

**Example: `shims/curl.json`**

```json
{
  "atip": "0.1",
  "name": "curl",
  "version": "8.4.0",
  "description": "Transfer data from or to a server",
  "commands": {
    "": {
      "description": "Make HTTP requests",
      "options": [
        {
          "name": "request",
          "flags": ["-X", "--request"],
          "type": "enum",
          "enum": ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD"],
          "description": "HTTP method"
        },
        {
          "name": "header",
          "flags": ["-H", "--header"],
          "type": "string",
          "description": "HTTP header (can be repeated)"
        },
        {
          "name": "data",
          "flags": ["-d", "--data"],
          "type": "string",
          "description": "Request body data"
        },
        {
          "name": "output",
          "flags": ["-o", "--output"],
          "type": "file",
          "description": "Write output to file"
        }
      ],
      "arguments": [
        {
          "name": "url",
          "type": "url",
          "required": true,
          "variadic": true,
          "description": "URL(s) to request"
        }
      ],
      "effects": {
        "network": true,
        "filesystem": {"write": true},
        "idempotent": false
      }
    }
  }
}
```

### 6.3 Auto-generation from --help

A reference tool can auto-generate ATIP metadata by parsing `--help` output:

```bash
$ atip-gen curl > shims/curl.json
```

This provides a starting point that humans can refine.

### 6.4 For AI platform providers

To adopt ATIP, platforms should:

1. **Scan for ATIP tools**: Add discovery of `--agent` supporting tools
2. **Read registry**: Load tool metadata from XDG locations
3. **Merge with MCP**: Combine ATIP introspection with MCP execution
4. **Expose to models**: Include ATIP metadata in tool context

---

## 7. Comparison to MCP

### 7.1 Complementary protocols

ATIP and MCP serve different purposes and work best together:

| Aspect | ATIP | MCP |
|--------|------|-----|
| **Primary purpose** | Tool introspection | Tool execution |
| **Infrastructure** | None (flag convention) | Server process |
| **Communication** | One-shot stdout | Bidirectional JSON-RPC |
| **Statefulness** | Stateless | Stateful sessions |
| **Authentication** | Describes requirements | Handles auth flows |
| **Streaming** | No | Yes (SSE) |
| **Dynamic discovery** | No (cached) | Yes (listChanged notification) |
| **Multi-client** | N/A | Yes |

### 7.2 Integration pattern

```
┌─────────────────────────────────────────────────────────────┐
│                      AI Coding Agent                        │
│                                                             │
│  ┌─────────────────────┐    ┌─────────────────────────┐    │
│  │   Tool Discovery    │    │    Tool Execution       │    │
│  │       (ATIP)        │    │       (MCP/Direct)      │    │
│  │                     │    │                         │    │
│  │  • --agent flag     │    │  • MCP servers          │    │
│  │  • Registry files   │    │  • Direct invocation    │    │
│  │  • Shims           │───►│  • Subprocess calls     │    │
│  │                     │    │                         │    │
│  └─────────────────────┘    └─────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
```

### 7.3 When to use which

**Use ATIP when:**
- You need to quickly enumerate available tools
- The tool doesn't need a running server
- You want zero-infrastructure introspection
- You're building a shim for a legacy tool

**Use MCP when:**
- The tool needs bidirectional communication
- You need streaming responses
- The tool has complex authentication flows
- Multiple clients need to share tool state

---

## 8. Example Implementations

### 8.1 GitHub CLI (`gh`)

```json
{
  "atip": "0.1",
  "name": "gh",
  "version": "2.45.0",
  "title": "GitHub CLI",
  "description": "Work seamlessly with GitHub from the command line",
  "homepage": "https://cli.github.com",
  "license": "MIT",
  "authentication": {
    "required": true,
    "methods": [
      {
        "type": "oauth",
        "setupCommand": "gh auth login",
        "scopes": ["repo", "read:org", "gist"]
      },
      {
        "type": "token",
        "envVar": "GITHUB_TOKEN"
      }
    ],
    "checkCommand": "gh auth status"
  },
  "globalOptions": [
    {
      "name": "repo",
      "flags": ["-R", "--repo"],
      "type": "string",
      "description": "Select repository using [HOST/]OWNER/REPO format"
    }
  ],
  "commands": {
    "pr": {
      "description": "Manage pull requests",
      "commands": {
        "create": {
          "description": "Create a pull request",
          "options": [
            {"name": "title", "flags": ["-t", "--title"], "type": "string", "description": "Title for the PR"},
            {"name": "body", "flags": ["-b", "--body"], "type": "string", "description": "Body for the PR"},
            {"name": "draft", "flags": ["-d", "--draft"], "type": "boolean", "description": "Mark as draft"},
            {"name": "base", "flags": ["-B", "--base"], "type": "string", "description": "Base branch"}
          ],
          "effects": {"network": true, "idempotent": false, "creates": ["pull_request"]},
          "examples": ["gh pr create --title 'Fix bug' --body 'Description'"]
        },
        "list": {
          "description": "List pull requests",
          "options": [
            {"name": "state", "flags": ["-s", "--state"], "type": "enum", "enum": ["open", "closed", "merged", "all"], "default": "open"},
            {"name": "json", "flags": ["--json"], "type": "string", "description": "Output JSON with specified fields"}
          ],
          "effects": {"network": true, "idempotent": true}
        },
        "merge": {
          "description": "Merge a pull request",
          "arguments": [{"name": "number", "type": "integer", "required": false, "description": "PR number"}],
          "options": [
            {"name": "merge", "flags": ["-m", "--merge"], "type": "boolean", "description": "Merge commit"},
            {"name": "squash", "flags": ["-s", "--squash"], "type": "boolean", "description": "Squash merge"},
            {"name": "rebase", "flags": ["-r", "--rebase"], "type": "boolean", "description": "Rebase merge"}
          ],
          "effects": {"network": true, "idempotent": false, "reversible": false, "modifies": ["pull_request", "branch"]}
        }
      }
    },
    "issue": {
      "description": "Manage issues",
      "commands": {
        "create": {
          "description": "Create a new issue",
          "options": [
            {"name": "title", "flags": ["-t", "--title"], "type": "string", "required": true},
            {"name": "body", "flags": ["-b", "--body"], "type": "string"},
            {"name": "label", "flags": ["-l", "--label"], "type": "string", "description": "Add labels (can repeat)"}
          ],
          "effects": {"network": true, "creates": ["issue"]}
        }
      }
    },
    "repo": {
      "description": "Manage repositories",
      "commands": {
        "clone": {
          "description": "Clone a repository locally",
          "arguments": [{"name": "repository", "type": "string", "required": true, "description": "Repository to clone"}],
          "effects": {"network": true, "filesystem": {"write": true}, "creates": ["directory"]}
        }
      }
    }
  },
  "patterns": [
    {
      "name": "review-pr",
      "description": "Checkout and review a pull request",
      "steps": [
        {"command": "gh pr checkout {number}", "description": "Checkout PR branch"},
        {"command": "gh pr diff {number}", "description": "View changes"},
        {"command": "gh pr review {number} --approve", "description": "Approve PR"}
      ]
    }
  ]
}
```

### 8.2 Kubernetes CLI (`kubectl`)

```json
{
  "atip": "0.1",
  "name": "kubectl",
  "version": "1.29.0",
  "title": "Kubernetes CLI",
  "description": "Control Kubernetes clusters",
  "homepage": "https://kubernetes.io/docs/reference/kubectl/",
  "authentication": {
    "required": true,
    "methods": [
      {"type": "certificate", "configPath": "~/.kube/config"},
      {"type": "token", "envVar": "KUBECONFIG"}
    ],
    "checkCommand": "kubectl cluster-info"
  },
  "globalOptions": [
    {"name": "namespace", "flags": ["-n", "--namespace"], "type": "string", "description": "Kubernetes namespace"},
    {"name": "context", "flags": ["--context"], "type": "string", "description": "Cluster context"},
    {"name": "output", "flags": ["-o", "--output"], "type": "enum", "enum": ["json", "yaml", "wide", "name"]}
  ],
  "commands": {
    "get": {
      "description": "Display resources",
      "arguments": [{"name": "resource", "type": "string", "required": true, "variadic": true}],
      "options": [
        {"name": "selector", "flags": ["-l", "--selector"], "type": "string", "description": "Label selector"},
        {"name": "all-namespaces", "flags": ["-A", "--all-namespaces"], "type": "boolean"}
      ],
      "effects": {"network": true, "idempotent": true},
      "examples": ["kubectl get pods", "kubectl get pods -o json", "kubectl get svc,deploy"]
    },
    "apply": {
      "description": "Apply configuration to resources",
      "options": [
        {"name": "filename", "flags": ["-f", "--filename"], "type": "file", "required": true},
        {"name": "dry-run", "flags": ["--dry-run"], "type": "enum", "enum": ["none", "client", "server"]}
      ],
      "effects": {"network": true, "idempotent": true, "modifies": ["kubernetes_resource"]},
      "examples": ["kubectl apply -f deployment.yaml"]
    },
    "delete": {
      "description": "Delete resources",
      "arguments": [{"name": "resource", "type": "string", "required": true}],
      "options": [
        {"name": "force", "flags": ["--force"], "type": "boolean"},
        {"name": "grace-period", "flags": ["--grace-period"], "type": "integer", "default": 30}
      ],
      "effects": {"network": true, "destructive": true, "reversible": false, "deletes": ["kubernetes_resource"]}
    },
    "exec": {
      "description": "Execute command in container",
      "arguments": [
        {"name": "pod", "type": "string", "required": true},
        {"name": "command", "type": "string", "required": true, "variadic": true}
      ],
      "options": [
        {"name": "container", "flags": ["-c", "--container"], "type": "string"},
        {"name": "stdin", "flags": ["-i", "--stdin"], "type": "boolean"},
        {"name": "tty", "flags": ["-t", "--tty"], "type": "boolean"}
      ],
      "effects": {"network": true, "subprocess": true, "idempotent": false}
    }
  }
}
```

### 8.3 Terraform

```json
{
  "atip": "0.1",
  "name": "terraform",
  "version": "1.7.0",
  "title": "Terraform",
  "description": "Infrastructure as Code tool for building, changing, and versioning infrastructure",
  "homepage": "https://terraform.io",
  "license": "BUSL-1.1",
  "globalOptions": [
    {"name": "chdir", "flags": ["-chdir"], "type": "directory", "description": "Switch to a different working directory"}
  ],
  "commands": {
    "init": {
      "description": "Initialize a Terraform working directory",
      "options": [
        {"name": "upgrade", "flags": ["-upgrade"], "type": "boolean", "description": "Upgrade modules and plugins"},
        {"name": "backend-config", "flags": ["-backend-config"], "type": "string", "description": "Backend configuration"}
      ],
      "effects": {
        "network": true,
        "filesystem": {"write": true, "paths": [".terraform/"]},
        "idempotent": true
      }
    },
    "plan": {
      "description": "Generate and show an execution plan",
      "options": [
        {"name": "out", "flags": ["-out"], "type": "file", "description": "Save plan to file"},
        {"name": "var", "flags": ["-var"], "type": "string", "description": "Set a variable"},
        {"name": "var-file", "flags": ["-var-file"], "type": "file", "description": "Variable definitions file"}
      ],
      "effects": {"network": true, "idempotent": true},
      "examples": ["terraform plan -out=tfplan"]
    },
    "apply": {
      "description": "Apply the changes required to reach the desired state",
      "arguments": [{"name": "plan", "type": "file", "required": false, "description": "Plan file to apply"}],
      "options": [
        {"name": "auto-approve", "flags": ["-auto-approve"], "type": "boolean", "description": "Skip approval prompt"}
      ],
      "effects": {
        "network": true,
        "idempotent": false,
        "reversible": true,
        "cost": {"billable": true, "estimate": "variable"},
        "creates": ["cloud_resource"],
        "modifies": ["cloud_resource"]
      }
    },
    "destroy": {
      "description": "Destroy Terraform-managed infrastructure",
      "options": [
        {"name": "auto-approve", "flags": ["-auto-approve"], "type": "boolean"}
      ],
      "effects": {
        "network": true,
        "destructive": true,
        "reversible": false,
        "cost": {"billable": true},
        "deletes": ["cloud_resource"]
      }
    },
    "output": {
      "description": "Show output values",
      "arguments": [{"name": "name", "type": "string", "required": false}],
      "options": [{"name": "json", "flags": ["-json"], "type": "boolean"}],
      "effects": {"idempotent": true}
    }
  }
}
```

---

## 9. Reference Implementation Notes

### 9.1 Minimal agent implementation

An agent implementing ATIP discovery needs approximately 200 lines of code:

```python
# atip_discovery.py - Minimal reference implementation

import json
import subprocess
import os
from pathlib import Path
from typing import Optional, Dict, Any

XDG_DATA_HOME = Path(os.environ.get("XDG_DATA_HOME", Path.home() / ".local/share"))
ATIP_DIR = XDG_DATA_HOME / "agent-tools"
REGISTRY_PATH = ATIP_DIR / "registry.json"

def probe_tool(tool_path: str, timeout: float = 2.0) -> Optional[Dict[str, Any]]:
    """Probe a tool for ATIP support."""
    try:
        result = subprocess.run(
            [tool_path, "--agent"],
            capture_output=True,
            text=True,
            timeout=timeout
        )
        if result.returncode == 0:
            metadata = json.loads(result.stdout)
            if "atip" in metadata:
                return metadata
    except (subprocess.TimeoutExpired, json.JSONDecodeError, FileNotFoundError):
        pass
    return None

def load_shim(tool_name: str) -> Optional[Dict[str, Any]]:
    """Load shim metadata for a tool."""
    shim_path = ATIP_DIR / "shims" / f"{tool_name}.json"
    if shim_path.exists():
        return json.loads(shim_path.read_text())
    return None

def discover_tool(tool_name: str) -> Optional[Dict[str, Any]]:
    """Discover metadata for a tool."""
    # Try native support first
    tool_path = subprocess.run(
        ["which", tool_name], capture_output=True, text=True
    ).stdout.strip()
    
    if tool_path:
        metadata = probe_tool(tool_path)
        if metadata:
            return {"source": "native", "metadata": metadata}
    
    # Fall back to shim
    shim = load_shim(tool_name)
    if shim:
        return {"source": "shim", "metadata": shim}
    
    return None

def get_tool_metadata(tool_name: str) -> Optional[Dict[str, Any]]:
    """Get metadata for a tool, using cache when available."""
    # Check registry cache
    if REGISTRY_PATH.exists():
        registry = json.loads(REGISTRY_PATH.read_text())
        if tool_name in registry.get("tools", {}):
            entry = registry["tools"][tool_name]
            # Load cached metadata
            if entry.get("source") == "native":
                return probe_tool(entry["path"])
            elif entry.get("source") == "shim":
                return load_shim(tool_name)
    
    # Discover and cache
    result = discover_tool(tool_name)
    if result:
        # Update registry (simplified - real impl would handle concurrency)
        update_registry(tool_name, result)
        return result["metadata"]
    
    return None
```

### 9.2 Minimal tool implementation

Adding ATIP support to an existing Go CLI:

```go
// main.go - Adding ATIP support to existing CLI

package main

import (
    "encoding/json"
    "fmt"
    "os"
)

var version = "1.0.0"

type ATIPMetadata struct {
    ATIP        string                 `json:"atip"`
    Name        string                 `json:"name"`
    Version     string                 `json:"version"`
    Description string                 `json:"description"`
    Commands    map[string]ATIPCommand `json:"commands"`
}

type ATIPCommand struct {
    Description string       `json:"description"`
    Options     []ATIPOption `json:"options"`
}

type ATIPOption struct {
    Name        string   `json:"name"`
    Flags       []string `json:"flags"`
    Type        string   `json:"type"`
    Description string   `json:"description"`
}

func handleAgentFlag() {
    metadata := ATIPMetadata{
        ATIP:        "0.1",
        Name:        "mytool",
        Version:     version,
        Description: "Example tool with ATIP support",
        Commands: map[string]ATIPCommand{
            "run": {
                Description: "Execute the main operation",
                Options: []ATIPOption{
                    {Name: "verbose", Flags: []string{"-v", "--verbose"}, 
                     Type: "boolean", Description: "Enable verbose output"},
                    {Name: "output", Flags: []string{"-o", "--output"}, 
                     Type: "file", Description: "Output file path"},
                },
            },
        },
    }
    
    encoder := json.NewEncoder(os.Stdout)
    encoder.SetIndent("", "  ")
    encoder.Encode(metadata)
    os.Exit(0)
}

func main() {
    for _, arg := range os.Args[1:] {
        if arg == "--agent" {
            handleAgentFlag()
        }
    }
    // ... rest of CLI
}
```

### 9.3 Shim generator tool

A tool to auto-generate shims from `--help` output:

```bash
#!/bin/bash
# atip-gen - Generate ATIP shim from --help parsing

TOOL=$1
OUTPUT="${2:-shims/${TOOL}.json}"

VERSION=$($TOOL --version 2>&1 | head -1 | grep -oE '[0-9]+\.[0-9]+(\.[0-9]+)?' | head -1)

cat > "$OUTPUT" << EOF
{
  "atip": "0.1",
  "name": "$TOOL",
  "version": "${VERSION:-unknown}",
  "description": "Auto-generated shim for $TOOL - REVIEW AND EDIT",
  "_generated": "$(date -Iseconds)",
  "_source": "atip-gen from --help parsing",
  "commands": {}
}
EOF

echo "Generated $OUTPUT - please review and complete manually"
```

---

## 10. Appendices

### Appendix A: JSON Schema for ATIP Metadata

The complete JSON Schema for validating ATIP metadata is available at:
`https://atip.dev/schema/0.1.json`

### Appendix B: MIME Type

ATIP metadata SHOULD use the MIME type:
`application/vnd.atip+json`

### Appendix C: Relationship to Other Standards

| Standard | Relationship |
|----------|--------------|
| MCP | Complementary (ATIP for introspection, MCP for execution) |
| OpenAPI | Borrows parameter/schema patterns |
| JSON Schema | Used for type definitions |
| XDG Base Directory | Used for file locations |
| Fig Completion Specs | Influenced command structure design |
| LSP | Influenced capability model |

### Appendix D: Version History

- **0.1** (January 2026): Initial draft

---

## Acknowledgments

This RFC draws on prior art from the Model Context Protocol (Anthropic), Language Server Protocol (Microsoft), Fig completion specifications (Amazon), XDG Base Directory Specification (freedesktop.org), and patterns from LangChain, OpenAI function calling, and the broader AI agent ecosystem.

---

## References

1. Model Context Protocol Specification - https://modelcontextprotocol.io
2. Language Server Protocol - https://microsoft.github.io/language-server-protocol/
3. XDG Base Directory Specification - https://specifications.freedesktop.org/basedir-spec/
4. JSON Schema - https://json-schema.org
5. OpenAPI Specification - https://spec.openapis.org/oas/latest.html
6. Fig Completion Specs - https://fig.io/docs/
7. GNU Coding Standards - https://www.gnu.org/prep/standards/

---

*This RFC is released for public comment. Feedback should be directed to [community discussion venue].*