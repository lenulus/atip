# RFC: Agent Tool Introspection Protocol (ATIP)

**RFC Number**: ATIP-0001  
**Status**: Draft  
**Authors**: [Community Proposal]  
**Created**: January 2026  
**Version**: 0.3.0

---

## Abstract

This document specifies a lightweight protocol for AI agents to discover and understand local command-line tools. The Agent Tool Introspection Protocol (ATIP) defines a `--agent` flag convention that outputs structured JSON metadata to stdout, canonical file locations for tool registries following XDG conventions, and a minimal schema for describing tool capabilities, side effects, and safety properties.

ATIP enables agents to discover tools and execute them directly via subprocess invocation‚Äîno server infrastructure required. The protocol includes:

- **Partial discovery** for tools with large command surfaces (avoiding context bloat)
- **Interactive tool handling** for commands requiring stdin or TTY
- **Translation rules** for compiling ATIP metadata into native function calling formats (OpenAI, Gemini, Anthropic)

---

## Table of Contents

1. [Motivation](#1-motivation)
2. [Design Goals](#2-design-goals)
3. [Specification](#3-specification)
4. [File Locations](#4-file-locations)
5. [Discovery Mechanism](#5-discovery-mechanism)
6. [Execution Model](#6-execution-model)
7. [Function Calling Lifecycle](#7-function-calling-lifecycle)
8. [Provider Translation Rules](#8-provider-translation-rules)
9. [Comparison to MCP](#9-comparison-to-mcp)
10. [Subagent Considerations](#10-subagent-considerations)
11. [Security Considerations](#11-security-considerations)
12. [Adoption Path](#12-adoption-path)
13. [Examples](#13-examples)
14. [References](#14-references)

---

## 1. Motivation

### 1.1 The problem: no standard for tool introspection

AI coding assistants like Claude Code and Gemini CLI need to understand what tools are available and how to use them. Currently, agents rely on:

- **Parsing `--help` output** ‚Äî Inconsistent formatting, unreliable extraction
- **Hardcoded knowledge** ‚Äî Doesn't scale, can't handle custom tools
- **MCP servers** ‚Äî Requires running server processes for simple CLI tools

None of these answer the questions agents actually need:
- What are the side effects? (destructive? network? filesystem?)
- What's the expected runtime/cost?
- Is this operation idempotent? Reversible?
- What are canonical usage patterns for this tool?

### 1.2 The insight: introspection ‚â† execution

MCP conflates two concerns:
1. **Introspection** ‚Äî What can this tool do?
2. **Execution** ‚Äî Run the tool and get results

For local CLI tools, execution is trivial‚Äîrun the binary, capture stdout/stderr, check exit code. Subprocess invocation has worked for decades.

What's missing is introspection. ATIP addresses this directly:

```bash
# Introspection (ATIP)
$ gh --agent
{ "atip": "0.1", "name": "gh", "commands": {...}, "effects": {...} }

# Execution (direct invocation)
$ gh pr list --json number,title
[{"number": 42, "title": "Fix bug"}]
```

No servers. No JSON-RPC. No handshakes.

### 1.3 Why not extend MCP?

MCP is well-designed for its purpose: exposing capabilities from servers (local or remote) to AI models. Its architecture assumes:

- A running server process
- Bidirectional communication
- Session lifecycle management
- Potential for streaming responses

For tools like Playwright (browser automation) or database explorers, this makes sense. For `gh`, `kubectl`, `terraform`, `git`, `npm`‚Äîtools that execute and exit‚ÄîMCP is pure overhead.

ATIP doesn't compete with MCP. It fills a different gap:

| Concern | Solution |
|---------|----------|
| Tool discovery/metadata | ATIP (`--agent` flag) |
| Tool execution (CLI tools) | Direct subprocess invocation |
| Tool execution (stateful tools) | MCP (when genuinely needed) |

---

## 2. Design Goals

### 2.1 Zero infrastructure

No servers, no daemons, no sockets, no ports. Tool introspection should work on a fresh system with only the tool binary installed.

### 2.2 Simplicity

A tool author can add ATIP support in 30 minutes. The `--agent` flag outputs JSON to stdout. No new dependencies required.

### 2.3 Incremental adoption

Tools can adopt ATIP without breaking existing behavior. The `--agent` flag is purely additive. Partial implementations are valid.

### 2.4 Composability

ATIP metadata can be layered with organizational patterns and institutional knowledge stored in separate files.

### 2.5 Direct execution

ATIP assumes agents will execute tools directly via subprocess. The protocol provides metadata to make execution decisions but does not prescribe an execution mechanism.

### 2.6 Universal translation

ATIP metadata must compile to the native function calling formats of major AI providers without loss of critical safety information.

---

## 3. Specification

### 3.1 The `--agent` flag convention

Tools supporting ATIP MUST respond to the `--agent` flag by outputting valid JSON to stdout and exiting with code 0 on success.

```bash
$ mytool --agent
{
  "atip": "0.1",
  "name": "mytool",
  "version": "2.3.1",
  ...
}
```

**Behavioral requirements:**

1. `--agent` MUST NOT perform any side effects
2. Output MUST be valid JSON (UTF-8 encoded)
3. Exit code MUST be 0 on success, non-zero on failure
4. Output MUST go to stdout; diagnostics MAY go to stderr

### 3.1.1 Partial discovery (context optimization)

Tools with large command surfaces (e.g., `kubectl`, `aws`, `gcloud`) SHOULD support filtered discovery to avoid context bloat:

```bash
# Full metadata (may be very large)
$ kubectl --agent

# Filtered to specific subcommand tree
$ kubectl --agent --commands=pods,deployments

# Top-level only (commands without full subcommand expansion)
$ kubectl --agent --depth=1
```

**Optional flags:**

| Flag | Description |
|------|-------------|
| `--commands=a,b,c` | Return only specified command subtrees |
| `--depth=N` | Limit subcommand nesting depth (1 = top-level only) |

When partial discovery is used, the root object SHOULD include:

```json
{
  "atip": "0.1",
  "partial": true,
  "filter": {"commands": ["pods", "deployments"], "depth": null},
  "totalCommands": 347,
  "includedCommands": 24,
  ...
}
```

**Agent strategy:**

1. First call: `tool --agent --depth=1` to get overview
2. Based on task, call: `tool --agent --commands=relevant_subset`
3. Cache full metadata only for frequently-used tools

### 3.2 Root schema

```json
{
  "atip": "0.1",
  "name": "gh",
  "version": "2.45.0",
  "description": "Work seamlessly with GitHub from the command line",
  "homepage": "https://cli.github.com",
  "commands": { ... },
  "globalOptions": [ ... ],
  "authentication": { ... },
  "effects": { ... },
  "patterns": [ ... ]
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `atip` | string | YES | Protocol version ("0.1") |
| `name` | string | YES | Command name (matches executable) |
| `version` | string | YES | Tool version |
| `description` | string | YES | One-line description (‚â§200 chars recommended) |
| `homepage` | string | NO | URL for documentation |
| `commands` | object | NO | Subcommand definitions |
| `globalOptions` | array | NO | Options available to all commands |
| `authentication` | object | NO | Authentication requirements |
| `effects` | object | NO | Global side-effect declarations |
| `patterns` | array | NO | Common usage patterns |

### 3.3 Command schema

```json
{
  "commands": {
    "pr": {
      "description": "Manage pull requests",
      "commands": {
        "create": {
          "description": "Create a pull request",
          "arguments": [...],
          "options": [...],
          "effects": {
            "network": true,
            "idempotent": false,
            "reversible": true,
            "destructive": false,
            "creates": ["pull_request"]
          },
          "examples": [
            "gh pr create --title \"Fix bug\" --body \"Description\""
          ]
        }
      }
    }
  }
}
```

### 3.4 Argument schema

```json
{
  "arguments": [
    {
      "name": "file",
      "type": "file",
      "required": true,
      "description": "File to process",
      "variadic": false
    }
  ]
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `name` | string | YES | Argument name |
| `type` | string | YES | See Type System (¬ß3.7) |
| `description` | string | YES | What this argument represents |
| `required` | boolean | NO | Default: true |
| `default` | any | NO | Default value |
| `variadic` | boolean | NO | Accepts multiple values |
| `enum` | array | NO | Allowed values |

### 3.5 Option schema

```json
{
  "options": [
    {
      "name": "output",
      "flags": ["-o", "--output"],
      "type": "enum",
      "enum": ["json", "yaml", "text"],
      "default": "text",
      "description": "Output format",
      "envVar": "GH_OUTPUT_FORMAT"
    }
  ]
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `name` | string | YES | Option name |
| `flags` | array | YES | CLI flags ["-x", "--extended"] |
| `type` | string | YES | See Type System (¬ß3.7) |
| `description` | string | YES | What this option controls |
| `required` | boolean | NO | Default: false |
| `default` | any | NO | Default value |
| `enum` | array | NO | Allowed values |
| `envVar` | string | NO | Environment variable override |

### 3.6 Effects schema

The effects object enables agents to make informed safety decisions:

```json
{
  "effects": {
    "filesystem": {
      "read": true,
      "write": true,
      "delete": false,
      "paths": ["./", "~/.config/mytool/"]
    },
    "network": true,
    "subprocess": false,
    "idempotent": true,
    "reversible": false,
    "destructive": false,
    "creates": ["resource_type"],
    "modifies": ["resource_type"],
    "deletes": ["resource_type"],
    "interactive": {
      "stdin": "none",
      "prompts": false,
      "tty": false
    },
    "cost": {
      "estimate": "low",
      "billable": false
    },
    "duration": {
      "typical": "1-5s",
      "timeout": "60s"
    }
  }
}
```

| Field | Type | Description | Translation Priority |
|-------|------|-------------|---------------------|
| `idempotent` | boolean | Safe to retry | HIGH - embed in description |
| `reversible` | boolean | Can be undone | HIGH - embed in description |
| `destructive` | boolean | Permanently destroys data | CRITICAL - embed in description |
| `network` | boolean | Makes network requests | MEDIUM - embed if space |
| `filesystem.write` | boolean | Writes files | MEDIUM |
| `filesystem.delete` | boolean | Deletes files | HIGH |
| `cost.billable` | boolean | May incur cost | HIGH - embed in description |
| `interactive.stdin` | enum | Stdin requirements (see below) | HIGH - affects execution |
| `interactive.prompts` | boolean | May prompt for confirmation | HIGH - affects execution |
| `interactive.tty` | boolean | Requires TTY/PTY | HIGH - affects execution |

**Interactive stdin values:**

| Value | Description | Agent behavior |
|-------|-------------|----------------|
| `"none"` | No stdin expected | Normal subprocess |
| `"optional"` | Accepts stdin but works without | Normal subprocess |
| `"required"` | Blocks waiting for stdin | Use PTY, pipe input, or skip |
| `"password"` | Prompts for sensitive input | Use credential helper or skip |

**Agent handling of interactive tools:**

```python
def execute_tool(command, effects):
    interactive = effects.get("interactive", {})
    
    if interactive.get("stdin") == "required":
        # Option 1: Skip with explanation
        return Error("Tool requires interactive input")
        
        # Option 2: Auto-confirm if available
        command = add_flag(command, "--yes")  # or -y, --force, etc.
        
        # Option 3: Use PTY for real interaction
        return run_in_pty(command)
    
    if interactive.get("tty"):
        return run_in_pty(command)
    
    return subprocess.run(command, capture_output=True)
```

**Translation Priority** indicates which fields MUST be preserved when compiling to provider formats (see ¬ß8).

### 3.7 Type system

| Type | Description | JSON Schema |
|------|-------------|-------------|
| `string` | Text value | `{"type": "string"}` |
| `integer` | Whole number | `{"type": "integer"}` |
| `number` | Floating point | `{"type": "number"}` |
| `boolean` | True/false flag | `{"type": "boolean"}` |
| `file` | File path | `{"type": "string", "format": "file-path"}` |
| `directory` | Directory path | `{"type": "string", "format": "directory-path"}` |
| `url` | URL | `{"type": "string", "format": "uri"}` |
| `enum` | One of allowed values | `{"type": "string", "enum": [...]}` |
| `array` | List of values | `{"type": "array", "items": {...}}` |

### 3.8 Authentication schema

```json
{
  "authentication": {
    "required": true,
    "methods": [
      {
        "type": "token",
        "envVar": "GITHUB_TOKEN",
        "description": "Personal access token"
      },
      {
        "type": "oauth",
        "setupCommand": "gh auth login"
      }
    ],
    "checkCommand": "gh auth status"
  }
}
```

### 3.9 Patterns schema

```json
{
  "patterns": [
    {
      "name": "feature-branch-workflow",
      "description": "Create feature branch, make changes, open PR",
      "steps": [
        {"command": "git checkout -b {branch}", "description": "Create branch"},
        {"command": "gh pr create --fill", "description": "Open PR"}
      ],
      "variables": {
        "branch": {"type": "string", "description": "Branch name"}
      }
    }
  ]
}
```

---

## 4. File Locations

Following the XDG Base Directory Specification:

```
$XDG_DATA_HOME/agent-tools/          # ~/.local/share/agent-tools/
‚îú‚îÄ‚îÄ registry.json                    # Index of discovered tools
‚îú‚îÄ‚îÄ tools/                           # Cached tool metadata
‚îÇ   ‚îú‚îÄ‚îÄ gh.json
‚îÇ   ‚îî‚îÄ‚îÄ kubectl.json
‚îú‚îÄ‚îÄ patterns/                        # Workflow patterns
‚îÇ   ‚îî‚îÄ‚îÄ org-deploy.json
‚îî‚îÄ‚îÄ shims/                           # Metadata for legacy tools
    ‚îî‚îÄ‚îÄ curl.json

$XDG_CONFIG_HOME/agent-tools/        # ~/.config/agent-tools/
‚îú‚îÄ‚îÄ config.json                      # User preferences
‚îî‚îÄ‚îÄ overrides/                       # User customizations
    ‚îî‚îÄ‚îÄ gh.json

/usr/share/agent-tools/              # System-wide definitions
/usr/local/share/agent-tools/        # Local system tools
```

---

## 5. Discovery Mechanism

### 5.1 Discovery algorithm

1. **Registry check**: Load known tools from `registry.json`
2. **Canonical directories**: Scan XDG locations
3. **PATH scanning**: Probe executables with `--agent` (cached)
4. **Shim fallback**: Load shim files for legacy tools

### 5.2 PATH scanning

```bash
for executable in $PATH/*:
    if not in skip_list:
        result = run(executable --agent, timeout=2s)
        if result.exit_code == 0 and is_valid_atip(result.stdout):
            add_to_registry(executable, source="native")
```

---

## 6. Execution Model

### 6.1 Direct invocation (default)

ATIP provides metadata. Agents execute tools directly:

```python
# Discovery
metadata = get_atip_metadata("gh")

# Decision making
if metadata["commands"]["pr"]["merge"]["effects"]["destructive"]:
    confirm_with_user()

# Execution (direct subprocess)
result = subprocess.run(["gh", "pr", "merge", "42"], capture_output=True)
```

No intermediate layer. The tool's native interface is the execution interface.

### 6.2 When MCP is appropriate

MCP adds value for a small subset of tools:

| Tool type | Why MCP helps |
|-----------|---------------|
| Browser automation | Persistent session, page state |
| Database clients | Connection pooling, transactions |
| Remote APIs | No local binary, auth handling |
| Streaming tools | Real-time output |

For these cases, tools may support both ATIP (discovery) and MCP (execution).

### 6.3 Hybrid architecture

```
Agent discovers tools:
  ‚Üí All tools: check --agent flag or shims (ATIP)

Agent executes tools:
  ‚Üí CLI tools (95%): direct subprocess invocation
  ‚Üí Stateful tools (5%): MCP if available
```

---

## 7. Function Calling Lifecycle

When an agent uses ATIP metadata with an LLM, it must translate the metadata into the LLM's native function calling format and manage the execution lifecycle.

### 7.1 Universal lifecycle

All major providers follow a similar pattern:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  1. REGISTRATION                                                ‚îÇ
‚îÇ     Agent loads ATIP metadata ‚Üí Compiles to provider format     ‚îÇ
‚îÇ     ‚Üí Sends tool definitions with request                       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  2. SELECTION                                                   ‚îÇ
‚îÇ     LLM analyzes user request ‚Üí Decides to call tool            ‚îÇ
‚îÇ     ‚Üí Returns structured tool call with arguments               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  3. VALIDATION (Agent responsibility)                           ‚îÇ
‚îÇ     Agent receives tool call ‚Üí Checks effects metadata          ‚îÇ
‚îÇ     ‚Üí Applies safety policies ‚Üí Requests confirmation if needed ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  4. EXECUTION                                                   ‚îÇ
‚îÇ     Agent invokes tool directly (subprocess)                    ‚îÇ
‚îÇ     ‚Üí Captures stdout/stderr/exit code                          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  5. RESULT                                                      ‚îÇ
‚îÇ     Agent formats result ‚Üí Returns to LLM                       ‚îÇ
‚îÇ     ‚Üí LLM synthesizes response (may chain more calls)           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 7.2 Provider-specific message formats

#### OpenAI

```python
# Registration
tools = [compile_to_openai(atip_tool) for atip_tool in tools]
response = client.chat.completions.create(
    model="gpt-4",
    messages=messages,
    tools=tools,
    tool_choice="auto"
)

# Tool call extraction
tool_calls = response.choices[0].message.tool_calls
for call in tool_calls:
    # call.id, call.function.name, call.function.arguments
    
# Result return (role="tool")
messages.append({
    "role": "tool",
    "tool_call_id": call.id,
    "content": result_string
})
```

#### Gemini

```python
# Registration
tools = [{"function_declarations": [compile_to_gemini(t) for t in tools]}]
response = model.generate_content(
    contents=contents,
    tools=tools,
    tool_config={"function_calling_config": {"mode": "AUTO"}}
)

# Tool call extraction
for part in response.candidates[0].content.parts:
    if part.function_call:
        # part.function_call.name, part.function_call.args

# Result return (in user message)
contents.append({
    "role": "user",
    "parts": [{"function_response": {"name": name, "response": result}}]
})
```

#### Anthropic

```python
# Registration
tools = [compile_to_anthropic(atip_tool) for atip_tool in tools]
response = client.messages.create(
    model="claude-sonnet-4-20250514",
    messages=messages,
    tools=tools,
    tool_choice={"type": "auto"}
)

# Tool call extraction (content blocks)
for block in response.content:
    if block.type == "tool_use":
        # block.id, block.name, block.input

# Result return (in user message)
messages.append({
    "role": "user",
    "content": [{
        "type": "tool_result",
        "tool_use_id": block.id,
        "content": result_string
    }]
})
```

### 7.3 Parallel tool calling

All three providers support multiple tool calls in a single response:

| Provider | Mechanism | Correlation |
|----------|-----------|-------------|
| OpenAI | Multiple `tool_calls` array entries | `tool_call_id` |
| Gemini | Multiple `function_call` parts | Positional order |
| Anthropic | Multiple `tool_use` blocks | `tool_use_id` |

Agents SHOULD execute parallel calls concurrently when effects metadata indicates no conflicts.

---

## 8. Provider Translation Rules

### 8.1 Schema compilation

ATIP metadata must compile to each provider's native format:

#### OpenAI format

```json
{
  "type": "function",
  "function": {
    "name": "gh_pr_create",
    "description": "Create a pull request. [‚ö†Ô∏è NOT IDEMPOTENT | CREATES: pull_request]",
    "strict": true,
    "parameters": {
      "type": "object",
      "properties": {
        "title": {"type": ["string", "null"], "description": "PR title"},
        "draft": {"type": "boolean", "description": "Mark as draft"}
      },
      "required": ["title", "draft"],
      "additionalProperties": false
    }
  }
}
```

#### Gemini format

```json
{
  "name": "gh_pr_create",
  "description": "Create a pull request. [‚ö†Ô∏è NOT IDEMPOTENT | CREATES: pull_request]",
  "parameters": {
    "type": "object",
    "properties": {
      "title": {"type": "string", "description": "PR title"},
      "draft": {"type": "boolean", "description": "Mark as draft"}
    },
    "required": ["title"]
  }
}
```

#### Anthropic format

```json
{
  "name": "gh_pr_create",
  "description": "Create a pull request. [‚ö†Ô∏è NOT IDEMPOTENT | CREATES: pull_request]",
  "input_schema": {
    "type": "object",
    "properties": {
      "title": {"type": "string", "description": "PR title"},
      "draft": {"type": "boolean", "description": "Mark as draft"}
    },
    "required": ["title"]
  }
}
```

### 8.2 Critical translation rules

#### Rule 1: Safety metadata tunneling

No provider natively supports effects metadata. Safety information MUST be embedded in descriptions:

```
Format: "{description} [{SAFETY_FLAGS}]"

SAFETY_FLAGS (space-separated):
  ‚ö†Ô∏è DESTRUCTIVE     - destructive: true
  ‚ö†Ô∏è NOT REVERSIBLE  - reversible: false  
  ‚ö†Ô∏è NOT IDEMPOTENT  - idempotent: false
  üí∞ BILLABLE        - cost.billable: true
  üîí READ-ONLY       - filesystem.write: false, network: false
  
Example:
  "Delete a repository permanently. [‚ö†Ô∏è DESTRUCTIVE | ‚ö†Ô∏è NOT REVERSIBLE]"
```

**Description length limits:**
- OpenAI: 1024 characters (enforced)
- Gemini: No explicit limit
- Anthropic: No explicit limit

Safety flags MUST fit within OpenAI's limit.

#### Rule 2: Optional parameters in strict mode

OpenAI strict mode requires all properties in `required` array. Transform optional parameters to nullable:

```python
def transform_optional_to_nullable(param):
    if not param.get("required", True):
        return {
            **param,
            "type": [param["type"], "null"]
        }
    return param
```

#### Rule 3: Subcommand flattening

CLI tools with nested subcommands must be flattened. Two strategies:

**Strategy A: Discrete tools (recommended)**
```
gh pr create  ‚Üí  gh_pr_create
gh pr list    ‚Üí  gh_pr_list
gh pr merge   ‚Üí  gh_pr_merge
```

**Strategy B: Action discriminator**
```json
{
  "name": "gh_pr",
  "parameters": {
    "action": {"type": "string", "enum": ["create", "list", "merge"]},
    "title": {"type": ["string", "null"]},
    "number": {"type": ["integer", "null"]}
  }
}
```

Strategy A preferred when subcommands have distinct parameter schemas.

#### Rule 4: Type coercion

| ATIP Type | OpenAI | Gemini | Anthropic |
|-----------|--------|--------|-----------|
| `file` | `string` | `string` | `string` |
| `directory` | `string` | `string` | `string` |
| `url` | `string` | `string` | `string` |
| `enum` | `string` + `enum` | `string` + `enum` | `string` + `enum` |

The `format` field is not reliably supported; use description to clarify expected format.

### 8.3 Translation matrix

| ATIP Field | OpenAI | Gemini | Anthropic | Preservation |
|------------|--------|--------|-----------|--------------|
| `name` | `function.name` | `name` | `name` | Full |
| `description` | `function.description` | `description` | `description` | Full |
| `arguments` | `parameters.properties` | `parameters.properties` | `input_schema.properties` | Full |
| `options` | `parameters.properties` | `parameters.properties` | `input_schema.properties` | Full |
| `effects.destructive` | Description suffix | Description suffix | Description suffix | Partial (lossy) |
| `effects.idempotent` | Description suffix | Description suffix | Description suffix | Partial (lossy) |
| `effects.reversible` | Description suffix | Description suffix | Description suffix | Partial (lossy) |
| `effects.interactive` | Not translated | Not translated | Not translated | Agent-only |
| `patterns` | System prompt | System prompt | System prompt | External |
| `authentication` | Out-of-band | Out-of-band | Out-of-band | External |
| `examples` | Description or system prompt | Description | Description | Partial |

**Agent-only fields** (`interactive`, `duration`, `authentication`) are not sent to the LLM. They inform agent-side execution decisions.

### 8.4 Reference implementation

```python
def compile_to_provider(atip_tool: dict, provider: str, strict: bool = False) -> dict:
    """Compile ATIP metadata to provider-specific format."""
    
    # Flatten subcommands to discrete tools
    tools = flatten_subcommands(atip_tool)
    
    compiled = []
    for tool in tools:
        # Build safety suffix
        safety = build_safety_suffix(tool.get("effects", {}))
        description = f"{tool['description']} {safety}".strip()
        
        # Truncate for OpenAI
        if provider == "openai" and len(description) > 1024:
            description = description[:1021] + "..."
        
        # Transform parameters
        params = transform_parameters(
            tool.get("arguments", []) + tool.get("options", []),
            provider=provider,
            strict=strict
        )
        
        if provider == "openai":
            compiled.append({
                "type": "function",
                "function": {
                    "name": tool["name"],
                    "description": description,
                    "strict": strict,
                    "parameters": params
                }
            })
        elif provider == "gemini":
            compiled.append({
                "name": tool["name"],
                "description": description,
                "parameters": params
            })
        elif provider == "anthropic":
            compiled.append({
                "name": tool["name"],
                "description": description,
                "input_schema": params
            })
    
    return compiled

def build_safety_suffix(effects: dict) -> str:
    """Build safety flag suffix for description."""
    flags = []
    if effects.get("destructive"):
        flags.append("‚ö†Ô∏è DESTRUCTIVE")
    if effects.get("reversible") == False:
        flags.append("‚ö†Ô∏è NOT REVERSIBLE")
    if effects.get("idempotent") == False:
        flags.append("‚ö†Ô∏è NOT IDEMPOTENT")
    if effects.get("cost", {}).get("billable"):
        flags.append("üí∞ BILLABLE")
    
    return f"[{' | '.join(flags)}]" if flags else ""
```

---

## 9. Comparison to MCP

### 9.1 Different problems, different solutions

| Aspect | ATIP | MCP |
|--------|------|-----|
| **Purpose** | Tool introspection | Stateful tool execution |
| **Infrastructure** | None | Server process |
| **Typical tools** | gh, kubectl, terraform | Playwright, databases |
| **When needed** | Always (for discovery) | Rarely |

### 9.2 Why not MCP for everything?

For `gh pr list`:

| Step | MCP approach | ATIP + direct |
|------|--------------|---------------|
| 1 | Start server | ‚Äî |
| 2 | Connect client | ‚Äî |
| 3 | Negotiate capabilities | Read cached metadata |
| 4 | JSON-RPC call | Run subprocess |
| 5 | Parse response | Parse stdout |
| 6 | Manage session | ‚Äî |

### 9.3 Complementary use

For stateful tools, both protocols work together:
- ATIP provides discovery
- MCP provides execution

---

## 10. Subagent Considerations

### 10.1 Shared tool knowledge

Multiple agents read from the same registry:

```
$XDG_DATA_HOME/agent-tools/registry.json
```

Lock-free reads. Atomic writes via temp-file-rename.

### 10.2 Capability delegation

Lead agents can restrict subagent tool access:

```json
{
  "delegation": {
    "allowedTools": ["gh", "git"],
    "deniedCommands": ["gh repo delete"],
    "effectRestrictions": {
      "destructive": false
    }
  }
}
```

### 10.3 Context sharing

Agents may share tool state:

```json
{
  "toolContext": {
    "availableTools": ["gh", "kubectl"],
    "authenticatedTools": ["gh"],
    "recentCommands": [
      {"tool": "gh", "command": "pr list", "exitCode": 0}
    ]
  }
}
```

---

## 11. Security Considerations

### 11.1 Trust boundaries

ATIP metadata is **descriptive, not prescriptive**. A malicious tool could lie about effects. Agents SHOULD:

- Confirm destructive operations regardless of metadata
- Use sandboxing for untrusted tools
- Verify tool binaries via checksums/signatures

### 11.2 Pre-execution validation

Agents MUST validate tool calls before execution:

```python
def validate_tool_call(tool_call, atip_metadata, policy):
    effects = atip_metadata["effects"]
    
    # Block destructive operations without confirmation
    if effects.get("destructive") and not policy.allow_destructive:
        raise RequiresConfirmation("Destructive operation")
    
    # Block billable operations without budget
    if effects.get("cost", {}).get("billable") and not policy.has_budget:
        raise BudgetExceeded("Operation may incur costs")
    
    # Sanitize arguments
    sanitize_paths(tool_call.arguments)
    check_injection(tool_call.arguments)
```

### 11.3 Post-execution filtering

Filter sensitive data from results before returning to LLM:

```python
def filter_result(result, tool_metadata):
    # Remove secrets, tokens, keys
    result = redact_patterns(result, SENSITIVE_PATTERNS)
    
    # Truncate large outputs
    if len(result) > MAX_RESULT_SIZE:
        result = result[:MAX_RESULT_SIZE] + "\n[truncated]"
    
    return result
```

---

## 12. Adoption Path

### 12.1 For tool authors

Minimal implementation:

```python
import json, sys

ATIP_METADATA = {
    "atip": "0.1",
    "name": "mytool",
    "version": "1.0.0",
    "description": "Does something useful",
    "commands": {
        "run": {
            "description": "Execute main function",
            "options": [
                {"name": "verbose", "flags": ["-v"], "type": "boolean", 
                 "description": "Verbose output"}
            ],
            "effects": {"idempotent": True, "network": False}
        }
    }
}

if "--agent" in sys.argv:
    print(json.dumps(ATIP_METADATA, indent=2))
    sys.exit(0)
```

### 12.2 For legacy tools

Create shim files:

```json
// ~/.local/share/agent-tools/shims/curl.json
{
  "atip": "0.1",
  "name": "curl",
  "version": "8.4.0",
  "description": "Transfer data from or to a server",
  "commands": {
    "": {
      "description": "Make HTTP request",
      "options": [
        {"name": "request", "flags": ["-X"], "type": "enum",
         "enum": ["GET", "POST", "PUT", "DELETE"]}
      ],
      "effects": {"network": true, "idempotent": false}
    }
  }
}
```

### 12.3 For AI platforms

1. Scan for ATIP tools on startup
2. Compile metadata to provider format
3. Execute tools directly via subprocess
4. Apply safety policies from effects metadata
5. Fall back to MCP only for stateful tools

---

## 13. Examples

### 13.1 GitHub CLI (gh)

```json
{
  "atip": "0.1",
  "name": "gh",
  "version": "2.45.0",
  "description": "GitHub CLI",
  "authentication": {
    "required": true,
    "methods": [{"type": "oauth", "setupCommand": "gh auth login"}],
    "checkCommand": "gh auth status"
  },
  "commands": {
    "pr": {
      "description": "Manage pull requests",
      "commands": {
        "list": {
          "description": "List pull requests",
          "options": [
            {"name": "state", "flags": ["-s", "--state"], "type": "enum",
             "enum": ["open", "closed", "merged", "all"], "default": "open"}
          ],
          "effects": {"network": true, "idempotent": true}
        },
        "create": {
          "description": "Create a pull request",
          "options": [
            {"name": "title", "flags": ["-t", "--title"], "type": "string"},
            {"name": "draft", "flags": ["-d", "--draft"], "type": "boolean"}
          ],
          "effects": {"network": true, "idempotent": false, "creates": ["pull_request"]}
        },
        "merge": {
          "description": "Merge a pull request",
          "arguments": [{"name": "number", "type": "integer", "required": false}],
          "effects": {"network": true, "idempotent": false, "reversible": false}
        }
      }
    },
    "repo": {
      "description": "Manage repositories",
      "commands": {
        "delete": {
          "description": "Delete a repository",
          "arguments": [{"name": "repo", "type": "string", "required": true}],
          "effects": {"network": true, "destructive": true, "reversible": false}
        }
      }
    }
  }
}
```

### 13.2 Compiled to OpenAI (strict mode)

```json
[
  {
    "type": "function",
    "function": {
      "name": "gh_pr_list",
      "description": "List pull requests",
      "strict": true,
      "parameters": {
        "type": "object",
        "properties": {
          "state": {
            "type": "string",
            "enum": ["open", "closed", "merged", "all"],
            "description": "Filter by state"
          }
        },
        "required": ["state"],
        "additionalProperties": false
      }
    }
  },
  {
    "type": "function",
    "function": {
      "name": "gh_repo_delete",
      "description": "Delete a repository. [‚ö†Ô∏è DESTRUCTIVE | ‚ö†Ô∏è NOT REVERSIBLE]",
      "strict": true,
      "parameters": {
        "type": "object",
        "properties": {
          "repo": {"type": "string", "description": "Repository to delete"}
        },
        "required": ["repo"],
        "additionalProperties": false
      }
    }
  }
]
```

---

## 14. References

1. XDG Base Directory Specification ‚Äî https://specifications.freedesktop.org/basedir-spec/
2. JSON Schema ‚Äî https://json-schema.org
3. Model Context Protocol ‚Äî https://modelcontextprotocol.io
4. OpenAI Function Calling ‚Äî https://platform.openai.com/docs/guides/function-calling
5. Gemini Function Calling ‚Äî https://ai.google.dev/docs/function_calling
6. Anthropic Tool Use ‚Äî https://docs.anthropic.com/claude/docs/tool-use
7. Command Line Interface Guidelines ‚Äî https://clig.dev

---

## Appendix A: atip-bridge Library Interface

```typescript
// Core transformers
export function toOpenAI(tool: AtipTool, options?: {strict?: boolean}): OpenAITool;
export function toGemini(tool: AtipTool): GeminiFunctionDeclaration;
export function toAnthropic(tool: AtipTool): AnthropicTool;

// Batch operations
export function compileTools(tools: AtipTool[], provider: Provider): ProviderTools;

// Safety utilities
export function generateSafetyPrompt(tools: AtipTool[]): string;
export function createValidator(tools: AtipTool[], policy: Policy): Validator;
export function createResultFilter(tools: AtipTool[]): ResultFilter;

// Lifecycle helpers
export function handleToolResult(provider: Provider, id: string, result: any): Message;
export function parseToolCall(provider: Provider, response: any): ToolCall[];
```

---

## Appendix B: Full JSON Schema

Available at: `https://atip.dev/schema/0.2.json`

---

*This RFC is released for public comment.*
