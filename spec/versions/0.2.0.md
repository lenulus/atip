# RFC: Agent Tool Introspection Protocol (ATIP)

**RFC Number**: ATIP-0001  
**Status**: Draft  
**Authors**: [Community Proposal]  
**Created**: January 2026  
**Version**: 0.1.0

---

## Abstract

This document specifies a lightweight protocol for AI agents to discover and understand local command-line tools. The Agent Tool Introspection Protocol (ATIP) defines a `--agent` flag convention that outputs structured JSON metadata to stdout, canonical file locations for tool registries following XDG conventions, and a minimal schema for describing tool capabilities, side effects, and safety properties. 

ATIP enables agents to discover tools and execute them directly via subprocess invocation—no server infrastructure required. The Model Context Protocol (MCP) remains useful for the minority of tools requiring persistent state or bidirectional communication (browsers, databases, remote APIs), but is unnecessary for standard CLI tools.

---

## 1. Motivation

### 1.1 The problem: no standard for tool introspection

AI coding assistants like Claude Code and Gemini CLI need to understand what tools are available and how to use them. Currently, agents rely on:

- **Parsing `--help` output** — Inconsistent formatting, unreliable extraction
- **Hardcoded knowledge** — Doesn't scale, can't handle custom tools
- **MCP servers** — Requires running server processes for simple CLI tools

None of these answer the questions agents actually need:
- What are the side effects? (destructive? network? filesystem?)
- What's the expected runtime/cost?
- Is this operation idempotent? Reversible?
- What are canonical usage patterns for this tool?

### 1.2 The insight: introspection ≠ execution

MCP conflates two concerns:
1. **Introspection** — What can this tool do?
2. **Execution** — Run the tool and get results

For local CLI tools, execution is trivial—run the binary, capture stdout/stderr, check exit code. Subprocess invocation has worked for decades.

What's missing is introspection. ATIP addresses this directly:

```bash
# Introspection (ATIP)
$ gh --agent
{ "atip": "0.1", "name": "gh", "commands": {...}, "effects": {...} }

# Execution (direct invocation)
$ gh pr list --json number,title
[{"number": 42, "title": "Fix bug"}]
```

No servers. No JSON-RPC. No handshakes.

### 1.3 Why not extend MCP?

MCP is well-designed for its purpose: exposing capabilities from servers (local or remote) to AI models. Its architecture assumes:

- A running server process
- Bidirectional communication
- Session lifecycle management
- Potential for streaming responses

For tools like Playwright (browser automation) or database explorers, this makes sense. For `gh`, `kubectl`, `terraform`, `git`, `npm`—tools that execute and exit—MCP is pure overhead.

ATIP doesn't compete with MCP. It fills a different gap:

| Concern | Solution |
|---------|----------|
| Tool discovery/metadata | ATIP (`--agent` flag) |
| Tool execution (CLI tools) | Direct subprocess invocation |
| Tool execution (stateful tools) | MCP (when genuinely needed) |

---

## 2. Design Goals

### 2.1 Zero infrastructure

No servers, no daemons, no sockets, no ports. Tool introspection should work on a fresh system with only the tool binary installed. This enables use in containers, CI environments, air-gapped machines, and restrictive corporate environments.

### 2.2 Simplicity

A tool author can add ATIP support in 30 minutes. The `--agent` flag outputs JSON to stdout. No new dependencies, no configuration files required.

### 2.3 Incremental adoption

Tools can adopt ATIP without breaking existing behavior. The `--agent` flag is purely additive. Tools without native support can be wrapped via shims. Partial implementations are valid and useful.

### 2.4 Composability

ATIP metadata can be layered. Base tool metadata can be extended with organizational patterns, workflow definitions, and institutional knowledge stored in separate files.

### 2.5 Direct execution

ATIP assumes agents will execute tools directly via subprocess. The protocol provides metadata to make execution decisions (is this safe? what are the effects?) but does not prescribe an execution mechanism.

---

## 3. Specification

### 3.1 The `--agent` flag convention

Tools supporting ATIP MUST respond to the `--agent` flag by outputting valid JSON to stdout and exiting with code 0 on success.

```bash
$ mytool --agent
{
  "atip": "0.1",
  "name": "mytool",
  "version": "2.3.1",
  ...
}
```

**Behavioral requirements:**

1. `--agent` MUST NOT perform any side effects (no network calls, no file writes, no prompts)
2. Output MUST be valid JSON (UTF-8 encoded)
3. Exit code MUST be 0 on success, non-zero on failure
4. Output MUST go to stdout; diagnostic messages MAY go to stderr

**Discovery probing:**

Agents detect ATIP support by running `tool --agent` and checking:
- Exit code is 0
- Output parses as valid JSON
- Output contains `"atip"` version field

### 3.2 Root schema

```json
{
  "atip": "0.1",
  "name": "gh",
  "version": "2.45.0",
  "description": "Work seamlessly with GitHub from the command line",
  "homepage": "https://cli.github.com",
  "commands": { ... },
  "globalOptions": [ ... ],
  "authentication": { ... },
  "effects": { ... },
  "patterns": [ ... ]
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `atip` | string | YES | Protocol version ("0.1") |
| `name` | string | YES | Command name (matches executable) |
| `version` | string | YES | Tool version |
| `description` | string | YES | One-line description |
| `homepage` | string | NO | URL for documentation |
| `commands` | object | NO | Subcommand definitions |
| `globalOptions` | array | NO | Options available to all commands |
| `authentication` | object | NO | Authentication requirements |
| `effects` | object | NO | Global side-effect declarations |
| `patterns` | array | NO | Common usage patterns |

### 3.3 Command schema

```json
{
  "commands": {
    "pr": {
      "description": "Manage pull requests",
      "commands": {
        "create": {
          "description": "Create a pull request",
          "arguments": [...],
          "options": [...],
          "effects": {
            "network": true,
            "idempotent": false,
            "reversible": true,
            "creates": ["pull_request"]
          },
          "examples": [
            "gh pr create --title \"Fix bug\" --body \"Description\""
          ]
        }
      }
    }
  }
}
```

### 3.4 Effects schema (side effects and safety)

The effects object enables agents to make informed decisions about tool usage:

```json
{
  "effects": {
    "filesystem": {
      "read": true,
      "write": true,
      "delete": false,
      "paths": ["./", "~/.config/mytool/"]
    },
    "network": true,
    "idempotent": true,
    "reversible": false,
    "destructive": false,
    "creates": ["resource_type"],
    "modifies": ["resource_type"],
    "deletes": ["resource_type"],
    "cost": {
      "estimate": "low",
      "billable": false
    },
    "duration": {
      "typical": "1-5s",
      "timeout": "60s"
    }
  }
}
```

| Field | Type | Description |
|-------|------|-------------|
| `idempotent` | boolean | Safe to retry without side effects |
| `reversible` | boolean | Can be undone |
| `destructive` | boolean | Permanently destroys data |
| `network` | boolean | Makes network requests |
| `filesystem.write` | boolean | Writes files |
| `filesystem.delete` | boolean | Deletes files |
| `cost.billable` | boolean | May incur financial cost |

### 3.5 Authentication schema

```json
{
  "authentication": {
    "required": true,
    "methods": [
      {
        "type": "token",
        "envVar": "GITHUB_TOKEN",
        "description": "Personal access token"
      },
      {
        "type": "oauth",
        "setupCommand": "gh auth login"
      }
    ],
    "checkCommand": "gh auth status"
  }
}
```

### 3.6 Patterns schema (workflow knowledge)

Patterns encode institutional knowledge about how tools are commonly used:

```json
{
  "patterns": [
    {
      "name": "feature-branch-workflow",
      "description": "Create feature branch, make changes, open PR",
      "steps": [
        {"command": "git checkout -b {branch}", "description": "Create branch"},
        {"command": "gh pr create --fill", "description": "Open PR"}
      ],
      "variables": {
        "branch": {"type": "string", "description": "Branch name"}
      }
    }
  ]
}
```

---

## 4. File Locations

Following the XDG Base Directory Specification:

```
$XDG_DATA_HOME/agent-tools/          # ~/.local/share/agent-tools/
├── registry.json                    # Index of discovered tools
├── tools/                           # Cached tool metadata
│   ├── gh.json
│   └── kubectl.json
├── patterns/                        # Workflow patterns
│   └── org-deploy.json
└── shims/                           # Metadata for legacy tools
    └── curl.json
```

---

## 5. Discovery Mechanism

### 5.1 Discovery algorithm

1. **Registry check**: Load known tools from `registry.json`
2. **Canonical directories**: Scan `/usr/share/agent-tools/`, `$XDG_DATA_HOME/agent-tools/`
3. **PATH scanning**: Probe executables with `--agent` (cached, not on every run)
4. **Shim fallback**: Load shim files for tools without native support

### 5.2 PATH scanning

```bash
for executable in $PATH/*:
    if not in skip_list:
        result = run(executable --agent, timeout=2s)
        if result.exit_code == 0 and is_valid_atip(result.stdout):
            add_to_registry(executable, source="native")
```

---

## 6. Execution Model

### 6.1 Direct invocation (default)

ATIP provides metadata. Agents execute tools directly:

```python
# Discovery
metadata = get_atip_metadata("gh")

# Decision making
if metadata["commands"]["pr"]["merge"]["effects"]["destructive"]:
    confirm_with_user()

# Execution (direct subprocess)
result = subprocess.run(["gh", "pr", "merge", "42"], capture_output=True)
```

No intermediate layer. No protocol translation. The tool's native interface is the execution interface.

### 6.2 When MCP is appropriate

MCP adds value for a small subset of tools:

| Tool type | Why MCP helps |
|-----------|---------------|
| **Browser automation** | Persistent browser session, page state |
| **Database clients** | Connection pooling, transactions |
| **Remote APIs** | No local binary, auth handling |
| **Streaming tools** | Real-time output, progress updates |

For these cases, tools may support both ATIP (for discovery) and MCP (for execution).

### 6.3 Hybrid approach

```
Agent discovers tools:
  → All tools: check --agent flag or shims (ATIP)

Agent executes tools:
  → CLI tools (95%): direct subprocess invocation
  → Stateful tools (5%): MCP if available, else direct
```

---

## 7. Comparison to MCP

### 7.1 Different problems, different solutions

| Aspect | ATIP | MCP |
|--------|------|-----|
| **Purpose** | Tool introspection | Stateful tool execution |
| **Infrastructure** | None | Server process |
| **Typical tools** | gh, kubectl, terraform | Playwright, databases |
| **When needed** | Always (for discovery) | Rarely |

### 7.2 Why not MCP for everything?

For `gh pr list`:

| Step | MCP approach | ATIP + direct |
|------|--------------|---------------|
| 1 | Start server | — |
| 2 | Connect client | — |
| 3 | Negotiate capabilities | Read cached metadata |
| 4 | JSON-RPC call | Run subprocess |
| 5 | Parse response | Parse stdout |
| 6 | Manage session | — |

The simpler path is faster, requires no infrastructure, and works anywhere the binary exists.

### 7.3 ATIP complements MCP

For the minority of tools that need MCP:
- ATIP provides discovery (what tools exist, what can they do)
- MCP provides execution (with state management, bidirectional communication)

For the majority of tools:
- ATIP provides discovery
- Direct invocation provides execution

---

## 8. Subagent Considerations

### 8.1 Shared tool knowledge

Multiple agents/subagents read from the same registry:

```
$XDG_DATA_HOME/agent-tools/registry.json
```

Lock-free reads. Atomic writes via temp-file-rename.

### 8.2 Capability delegation

Lead agents can restrict subagent tool access:

```json
{
  "delegation": {
    "allowedTools": ["gh", "git"],
    "deniedCommands": ["gh repo delete"],
    "effectRestrictions": {
      "destructive": false
    }
  }
}
```

---

## 9. Security Considerations

### 9.1 Trust boundaries

ATIP metadata is **descriptive, not prescriptive**. A malicious tool could lie about effects. Agents SHOULD:

- Confirm destructive operations regardless of metadata
- Use sandboxing for untrusted tools
- Verify tool binaries via checksums/signatures

### 9.2 Permission scoping

Effects metadata enables policy-based permissions:

```json
{
  "autoApprove": {
    "effects.idempotent": true,
    "effects.network": false
  },
  "requireConfirmation": {
    "effects.destructive": true
  }
}
```

---

## 10. Adoption Path

### 10.1 For tool authors

Minimal implementation (30 minutes):

```python
import json, sys

if "--agent" in sys.argv:
    print(json.dumps({
        "atip": "0.1",
        "name": "mytool",
        "version": "1.0.0",
        "description": "Does something useful",
        "commands": {...}
    }))
    sys.exit(0)
```

### 10.2 For legacy tools

Create shim files in `~/.local/share/agent-tools/shims/`:

```json
{
  "atip": "0.1",
  "name": "curl",
  "version": "8.4.0",
  "description": "Transfer data from or to a server",
  "commands": {...}
}
```

### 10.3 For AI platforms

1. Scan for ATIP-supporting tools on startup
2. Load tool metadata into agent context
3. Execute tools directly via subprocess
4. Fall back to MCP only for tools that require it

---

## 11. Example: Complete gh Metadata

```json
{
  "atip": "0.1",
  "name": "gh",
  "version": "2.45.0",
  "description": "Work seamlessly with GitHub from the command line",
  "homepage": "https://cli.github.com",
  "authentication": {
    "required": true,
    "methods": [
      {"type": "oauth", "setupCommand": "gh auth login"},
      {"type": "token", "envVar": "GITHUB_TOKEN"}
    ],
    "checkCommand": "gh auth status"
  },
  "commands": {
    "pr": {
      "description": "Manage pull requests",
      "commands": {
        "list": {
          "description": "List pull requests",
          "options": [
            {"name": "state", "flags": ["-s", "--state"], "type": "enum", 
             "enum": ["open", "closed", "merged", "all"], "default": "open"}
          ],
          "effects": {"network": true, "idempotent": true}
        },
        "create": {
          "description": "Create a pull request",
          "options": [
            {"name": "title", "flags": ["-t", "--title"], "type": "string"},
            {"name": "draft", "flags": ["-d", "--draft"], "type": "boolean"}
          ],
          "effects": {"network": true, "idempotent": false, "creates": ["pull_request"]}
        },
        "merge": {
          "description": "Merge a pull request",
          "arguments": [
            {"name": "number", "type": "integer", "required": false}
          ],
          "effects": {
            "network": true,
            "idempotent": false,
            "reversible": false,
            "modifies": ["pull_request", "branch"]
          }
        }
      }
    },
    "repo": {
      "description": "Manage repositories",
      "commands": {
        "clone": {
          "description": "Clone a repository locally",
          "arguments": [
            {"name": "repository", "type": "string", "required": true}
          ],
          "effects": {
            "network": true,
            "filesystem": {"write": true},
            "creates": ["directory"]
          }
        },
        "delete": {
          "description": "Delete a repository",
          "arguments": [
            {"name": "repository", "type": "string", "required": true}
          ],
          "effects": {
            "network": true,
            "destructive": true,
            "reversible": false,
            "deletes": ["repository"]
          }
        }
      }
    }
  },
  "patterns": [
    {
      "name": "review-pr",
      "description": "Checkout and review a pull request",
      "steps": [
        {"command": "gh pr checkout {number}"},
        {"command": "gh pr diff {number}"},
        {"command": "gh pr review {number} --approve"}
      ]
    }
  ]
}
```

---

## 12. References

1. XDG Base Directory Specification - https://specifications.freedesktop.org/basedir-spec/
2. JSON Schema - https://json-schema.org
3. Model Context Protocol - https://modelcontextprotocol.io
4. Command Line Interface Guidelines - https://clig.dev

---

*This RFC is released for public comment.*
